/**
 * Generated by the Emboss compiler.  DO NOT EDIT!
 */
#ifndef TESTDATA_ENUM_CASE_EMB_H_
#define TESTDATA_ENUM_CASE_EMB_H_
#include <stdint.h>
#include <string.h>

#include <algorithm>
#include <type_traits>
#include <utility>

#include "runtime/cpp/emboss_cpp_util.h"

#include "runtime/cpp/emboss_prelude.h"

#include "runtime/cpp/emboss_enum_view.h"

#include "runtime/cpp/emboss_text_util.h"



/* NOLINTBEGIN */
namespace emboss {
namespace test {
enum class EnumShouty : ::std::uint64_t;

enum class EnumDefault : ::std::uint64_t;

namespace UseKCamelEnumCase {

}  // namespace UseKCamelEnumCase


template <class Storage>
class GenericUseKCamelEnumCaseView;

enum class EnumShoutyAndKCamel : ::std::uint64_t;

enum class EnumMixed : ::std::uint64_t;


enum class EnumShouty : ::std::uint64_t {
  FIRST = static_cast</**/::std::int32_t>(0LL),
  SECOND = static_cast</**/::std::int32_t>(1LL),
  TWO_WORD = static_cast</**/::std::int32_t>(2LL),
  THREE_WORD_ENUM = static_cast</**/::std::int32_t>(4LL),
  LONG_ENUM_VALUE_NAME = static_cast</**/::std::int32_t>(8LL),

};
template <class Enum>
class EnumTraits;

template <>
class EnumTraits<EnumShouty> final {
 public:
  static bool TryToGetEnumFromName(const char *emboss_reserved_local_name,
                                   EnumShouty *emboss_reserved_local_result) {
    if (emboss_reserved_local_name == nullptr) return false;
    if (!strcmp("FIRST", emboss_reserved_local_name)) {
      *emboss_reserved_local_result = EnumShouty::FIRST;
      return true;
    }

    if (!strcmp("SECOND", emboss_reserved_local_name)) {
      *emboss_reserved_local_result = EnumShouty::SECOND;
      return true;
    }

    if (!strcmp("TWO_WORD", emboss_reserved_local_name)) {
      *emboss_reserved_local_result = EnumShouty::TWO_WORD;
      return true;
    }

    if (!strcmp("THREE_WORD_ENUM", emboss_reserved_local_name)) {
      *emboss_reserved_local_result = EnumShouty::THREE_WORD_ENUM;
      return true;
    }

    if (!strcmp("LONG_ENUM_VALUE_NAME", emboss_reserved_local_name)) {
      *emboss_reserved_local_result = EnumShouty::LONG_ENUM_VALUE_NAME;
      return true;
    }

    return false;
  }

  static const char *TryToGetNameFromEnum(
      EnumShouty emboss_reserved_local_value) {
    switch (emboss_reserved_local_value) {
      case EnumShouty::FIRST: return "FIRST";

      case EnumShouty::SECOND: return "SECOND";

      case EnumShouty::TWO_WORD: return "TWO_WORD";

      case EnumShouty::THREE_WORD_ENUM: return "THREE_WORD_ENUM";

      case EnumShouty::LONG_ENUM_VALUE_NAME: return "LONG_ENUM_VALUE_NAME";

      default: return nullptr;
    }
  }

  static bool EnumIsKnown(EnumShouty emboss_reserved_local_value) {
    switch (emboss_reserved_local_value) {
      case EnumShouty::FIRST: return true;

      case EnumShouty::SECOND: return true;

      case EnumShouty::TWO_WORD: return true;

      case EnumShouty::THREE_WORD_ENUM: return true;

      case EnumShouty::LONG_ENUM_VALUE_NAME: return true;

      default:
        return false;
    }
  }

  static ::std::ostream &SendToOstream(::std::ostream &emboss_reserved_local_os,
                                       EnumShouty emboss_reserved_local_value) {
    const char *emboss_reserved_local_name =
        TryToGetNameFromEnum(emboss_reserved_local_value);
    if (emboss_reserved_local_name == nullptr) {
      emboss_reserved_local_os
          << static_cast</**/ ::std::underlying_type<EnumShouty>::type>(
                 emboss_reserved_local_value);
    } else {
      emboss_reserved_local_os << emboss_reserved_local_name;
    }
    return emboss_reserved_local_os;
  }
};

static inline bool TryToGetEnumFromName(
    const char *emboss_reserved_local_name,
    EnumShouty *emboss_reserved_local_result) {
  return EnumTraits<EnumShouty>::TryToGetEnumFromName(
      emboss_reserved_local_name, emboss_reserved_local_result);
}

static inline const char *TryToGetNameFromEnum(
    EnumShouty emboss_reserved_local_value) {
  return EnumTraits<EnumShouty>::TryToGetNameFromEnum(
      emboss_reserved_local_value);
}

static inline bool EnumIsKnown(EnumShouty emboss_reserved_local_value) {
  return EnumTraits<EnumShouty>::EnumIsKnown(emboss_reserved_local_value);
}

static inline ::std::ostream &operator<<(
    ::std::ostream &emboss_reserved_local_os,
    EnumShouty emboss_reserved_local_value) {
  return EnumTraits<EnumShouty>::SendToOstream(emboss_reserved_local_os,
                                             emboss_reserved_local_value);
}
enum class EnumDefault : ::std::uint64_t {
  kFirst = static_cast</**/::std::int32_t>(0LL),
  kSecond = static_cast</**/::std::int32_t>(1LL),
  kTwoWord = static_cast</**/::std::int32_t>(2LL),
  kThreeWordEnum = static_cast</**/::std::int32_t>(4LL),
  kLongEnumValueName = static_cast</**/::std::int32_t>(8LL),

};
template <class Enum>
class EnumTraits;

template <>
class EnumTraits<EnumDefault> final {
 public:
  static bool TryToGetEnumFromName(const char *emboss_reserved_local_name,
                                   EnumDefault *emboss_reserved_local_result) {
    if (emboss_reserved_local_name == nullptr) return false;
    if (!strcmp("FIRST", emboss_reserved_local_name)) {
      *emboss_reserved_local_result = EnumDefault::kFirst;
      return true;
    }

    if (!strcmp("SECOND", emboss_reserved_local_name)) {
      *emboss_reserved_local_result = EnumDefault::kSecond;
      return true;
    }

    if (!strcmp("TWO_WORD", emboss_reserved_local_name)) {
      *emboss_reserved_local_result = EnumDefault::kTwoWord;
      return true;
    }

    if (!strcmp("THREE_WORD_ENUM", emboss_reserved_local_name)) {
      *emboss_reserved_local_result = EnumDefault::kThreeWordEnum;
      return true;
    }

    if (!strcmp("LONG_ENUM_VALUE_NAME", emboss_reserved_local_name)) {
      *emboss_reserved_local_result = EnumDefault::kLongEnumValueName;
      return true;
    }

    return false;
  }

  static const char *TryToGetNameFromEnum(
      EnumDefault emboss_reserved_local_value) {
    switch (emboss_reserved_local_value) {
      case EnumDefault::kFirst: return "FIRST";

      case EnumDefault::kSecond: return "SECOND";

      case EnumDefault::kTwoWord: return "TWO_WORD";

      case EnumDefault::kThreeWordEnum: return "THREE_WORD_ENUM";

      case EnumDefault::kLongEnumValueName: return "LONG_ENUM_VALUE_NAME";

      default: return nullptr;
    }
  }

  static bool EnumIsKnown(EnumDefault emboss_reserved_local_value) {
    switch (emboss_reserved_local_value) {
      case EnumDefault::kFirst: return true;

      case EnumDefault::kSecond: return true;

      case EnumDefault::kTwoWord: return true;

      case EnumDefault::kThreeWordEnum: return true;

      case EnumDefault::kLongEnumValueName: return true;

      default:
        return false;
    }
  }

  static ::std::ostream &SendToOstream(::std::ostream &emboss_reserved_local_os,
                                       EnumDefault emboss_reserved_local_value) {
    const char *emboss_reserved_local_name =
        TryToGetNameFromEnum(emboss_reserved_local_value);
    if (emboss_reserved_local_name == nullptr) {
      emboss_reserved_local_os
          << static_cast</**/ ::std::underlying_type<EnumDefault>::type>(
                 emboss_reserved_local_value);
    } else {
      emboss_reserved_local_os << emboss_reserved_local_name;
    }
    return emboss_reserved_local_os;
  }
};

static inline bool TryToGetEnumFromName(
    const char *emboss_reserved_local_name,
    EnumDefault *emboss_reserved_local_result) {
  return EnumTraits<EnumDefault>::TryToGetEnumFromName(
      emboss_reserved_local_name, emboss_reserved_local_result);
}

static inline const char *TryToGetNameFromEnum(
    EnumDefault emboss_reserved_local_value) {
  return EnumTraits<EnumDefault>::TryToGetNameFromEnum(
      emboss_reserved_local_value);
}

static inline bool EnumIsKnown(EnumDefault emboss_reserved_local_value) {
  return EnumTraits<EnumDefault>::EnumIsKnown(emboss_reserved_local_value);
}

static inline ::std::ostream &operator<<(
    ::std::ostream &emboss_reserved_local_os,
    EnumDefault emboss_reserved_local_value) {
  return EnumTraits<EnumDefault>::SendToOstream(emboss_reserved_local_os,
                                             emboss_reserved_local_value);
}





namespace UseKCamelEnumCase {

}  // namespace UseKCamelEnumCase


template <class View>
struct EmbossReservedInternalIsGenericUseKCamelEnumCaseView;

template <class Storage>
class GenericUseKCamelEnumCaseView final {
 public:
  GenericUseKCamelEnumCaseView() : backing_() {}
  explicit GenericUseKCamelEnumCaseView(
       Storage emboss_reserved_local_bytes)
      : backing_(emboss_reserved_local_bytes) 
         {}

  template <typename OtherStorage>
  GenericUseKCamelEnumCaseView(
      const GenericUseKCamelEnumCaseView<OtherStorage> &emboss_reserved_local_other)
      : backing_{emboss_reserved_local_other.BackingStorage()}
         {}

  template <typename Arg,
            typename = typename ::std::enable_if<
                !EmbossReservedInternalIsGenericUseKCamelEnumCaseView<
                    typename ::std::remove_cv<typename ::std::remove_reference<
                        Arg>::type>::type>::value>::type>
  explicit GenericUseKCamelEnumCaseView(
       Arg &&emboss_reserved_local_arg)
      : backing_(::std::forward<Arg>(
            emboss_reserved_local_arg)) 
         {}
  template <typename Arg0, typename Arg1, typename... Args>
  explicit GenericUseKCamelEnumCaseView(
       Arg0 &&emboss_reserved_local_arg0,
      Arg1 &&emboss_reserved_local_arg1, Args &&... emboss_reserved_local_args)
      : backing_(::std::forward<Arg0>(emboss_reserved_local_arg0),
                 ::std::forward<Arg1>(emboss_reserved_local_arg1),
                 ::std::forward<Args>(
                     emboss_reserved_local_args)...) 
         {}

  template <typename OtherStorage>
  GenericUseKCamelEnumCaseView<Storage> &operator=(
      const GenericUseKCamelEnumCaseView<OtherStorage> &emboss_reserved_local_other) {
    backing_ = emboss_reserved_local_other.BackingStorage();
    return *this;
  }

  

  bool Ok() const {
    if (!IsComplete()) return false;

    if (!has_v().Known()) return false;
    if (has_v().ValueOrDefault() && !v().Ok()) return false;


    if (!has_first().Known()) return false;
    if (has_first().ValueOrDefault() && !first().Ok()) return false;


    if (!has_v_is_first().Known()) return false;
    if (has_v_is_first().ValueOrDefault() && !v_is_first().Ok()) return false;


    if (!has_IntrinsicSizeInBytes().Known()) return false;
    if (has_IntrinsicSizeInBytes().ValueOrDefault() && !IntrinsicSizeInBytes().Ok()) return false;


    if (!has_MaxSizeInBytes().Known()) return false;
    if (has_MaxSizeInBytes().ValueOrDefault() && !MaxSizeInBytes().Ok()) return false;


    if (!has_MinSizeInBytes().Known()) return false;
    if (has_MinSizeInBytes().ValueOrDefault() && !MinSizeInBytes().Ok()) return false;



    return true;
  }
  Storage BackingStorage() const { return backing_; }
  bool IsComplete() const {
    return backing_.Ok() && IntrinsicSizeInBytes().Ok() &&
           backing_.SizeInBytes() >=
               static_cast</**/ ::std::size_t>(
                   IntrinsicSizeInBytes().UncheckedRead());
  }
  static constexpr ::std::size_t SizeInBytes() {
    return static_cast</**/ ::std::size_t>(IntrinsicSizeInBytes().Read());
  }
  static constexpr bool SizeIsKnown() {
    return IntrinsicSizeInBytes().Ok();
  }


  template <typename OtherStorage>
  bool Equals(
      GenericUseKCamelEnumCaseView<OtherStorage> emboss_reserved_local_other) const {
    
    if (!has_v().Known()) return false;
    if (!emboss_reserved_local_other.has_v().Known()) return false;

    if (emboss_reserved_local_other.has_v().ValueOrDefault() &&
        !has_v().ValueOrDefault())
      return false;
    if (has_v().ValueOrDefault() &&
        !emboss_reserved_local_other.has_v().ValueOrDefault())
      return false;

    if (emboss_reserved_local_other.has_v().ValueOrDefault() &&
        has_v().ValueOrDefault() &&
        !v().Equals(emboss_reserved_local_other.v()))
      return false;

 return true;
  }
  template <typename OtherStorage>
  bool UncheckedEquals(
      GenericUseKCamelEnumCaseView<OtherStorage> emboss_reserved_local_other) const {
    
    if (emboss_reserved_local_other.has_v().ValueOr(false) &&
        !has_v().ValueOr(false))
      return false;
    if (has_v().ValueOr(false) &&
        !emboss_reserved_local_other.has_v().ValueOr(false))
      return false;

    if (emboss_reserved_local_other.has_v().ValueOr(false) &&
        has_v().ValueOr(false) &&
        !v().UncheckedEquals(emboss_reserved_local_other.v()))
      return false;

 return true;
  }
  template <typename OtherStorage>
  void UncheckedCopyFrom(
      GenericUseKCamelEnumCaseView<OtherStorage> emboss_reserved_local_other) const {
    backing_.UncheckedCopyFrom(
        emboss_reserved_local_other.BackingStorage(),
        emboss_reserved_local_other.IntrinsicSizeInBytes().UncheckedRead());
  }

  template <typename OtherStorage>
  void CopyFrom(
      GenericUseKCamelEnumCaseView<OtherStorage> emboss_reserved_local_other) const {
    backing_.CopyFrom(
        emboss_reserved_local_other.BackingStorage(),
        emboss_reserved_local_other.IntrinsicSizeInBytes().Read());
  }
  template <typename OtherStorage>
  bool TryToCopyFrom(
      GenericUseKCamelEnumCaseView<OtherStorage> emboss_reserved_local_other) const {
      return emboss_reserved_local_other.Ok() && backing_.TryToCopyFrom(
        emboss_reserved_local_other.BackingStorage(),
        emboss_reserved_local_other.IntrinsicSizeInBytes().Read());
  }

  template <class Stream>
  bool UpdateFromTextStream(Stream *emboss_reserved_local_stream) const {
    ::std::string emboss_reserved_local_brace;
    if (!::emboss::support::ReadToken(emboss_reserved_local_stream,
                                      &emboss_reserved_local_brace))
      return false;
    if (emboss_reserved_local_brace != "{") return false;
    for (;;) {
      ::std::string emboss_reserved_local_name;
      if (!::emboss::support::ReadToken(emboss_reserved_local_stream,
                                        &emboss_reserved_local_name))
        return false;
      if (emboss_reserved_local_name == ",")
        if (!::emboss::support::ReadToken(emboss_reserved_local_stream,
                                          &emboss_reserved_local_name))
          return false;
      if (emboss_reserved_local_name == "}") return true;
      ::std::string emboss_reserved_local_colon;
      if (!::emboss::support::ReadToken(emboss_reserved_local_stream,
                                        &emboss_reserved_local_colon))
        return false;
      if (emboss_reserved_local_colon != ":") return false;
      if (emboss_reserved_local_name == "v") {
        if (!v().UpdateFromTextStream(
                emboss_reserved_local_stream)) {
          return false;
        }
        continue;
      }

      return false;
    }
  }

  template <class Stream>
  void WriteToTextStream(
      Stream *emboss_reserved_local_stream,
      ::emboss::TextOutputOptions emboss_reserved_local_options) const {
    ::emboss::TextOutputOptions emboss_reserved_local_field_options =
        emboss_reserved_local_options.PlusOneIndent();
    if (emboss_reserved_local_options.multiline()) {
      emboss_reserved_local_stream->Write("{\n");
    } else {
      emboss_reserved_local_stream->Write("{");
    }
    bool emboss_reserved_local_wrote_field = false;
    if (has_v().ValueOr(false)) {
      if (!emboss_reserved_local_field_options.allow_partial_output() ||
          v().IsAggregate() || v().Ok()) {
        if (emboss_reserved_local_field_options.multiline()) {
          emboss_reserved_local_stream->Write(
              emboss_reserved_local_field_options.current_indent());
        } else {
          if (emboss_reserved_local_wrote_field) {
            emboss_reserved_local_stream->Write(",");
          }
          emboss_reserved_local_stream->Write(" ");
        }
        emboss_reserved_local_stream->Write("v: ");
        v().WriteToTextStream(emboss_reserved_local_stream,
                                           emboss_reserved_local_field_options);
        emboss_reserved_local_wrote_field = true;
        if (emboss_reserved_local_field_options.multiline()) {
          emboss_reserved_local_stream->Write("\n");
        }
      } else if (emboss_reserved_local_field_options.allow_partial_output() &&
                 emboss_reserved_local_field_options.comments() &&
                 !v().IsAggregate() && !v().Ok()) {
        if (emboss_reserved_local_field_options.multiline()) {
          emboss_reserved_local_stream->Write(
              emboss_reserved_local_field_options.current_indent());
        }
        emboss_reserved_local_stream->Write("# v: UNREADABLE\n");
      }
    }

    if (has_first().ValueOr(false) &&
        emboss_reserved_local_field_options.comments()) {
      if (!emboss_reserved_local_field_options.allow_partial_output() ||
          first().IsAggregate() || first().Ok()) {
        emboss_reserved_local_stream->Write(
            emboss_reserved_local_field_options.current_indent());
        emboss_reserved_local_stream->Write("# first: ");
        first().WriteToTextStream(emboss_reserved_local_stream,
                                           emboss_reserved_local_field_options);
        emboss_reserved_local_stream->Write("\n");
      } else {
        if (emboss_reserved_local_field_options.multiline()) {
          emboss_reserved_local_stream->Write(
              emboss_reserved_local_field_options.current_indent());
        }
        emboss_reserved_local_stream->Write("# first: UNREADABLE\n");
      }
    }

    if (has_v_is_first().ValueOr(false) &&
        emboss_reserved_local_field_options.comments()) {
      if (!emboss_reserved_local_field_options.allow_partial_output() ||
          v_is_first().IsAggregate() || v_is_first().Ok()) {
        emboss_reserved_local_stream->Write(
            emboss_reserved_local_field_options.current_indent());
        emboss_reserved_local_stream->Write("# v_is_first: ");
        v_is_first().WriteToTextStream(emboss_reserved_local_stream,
                                           emboss_reserved_local_field_options);
        emboss_reserved_local_stream->Write("\n");
      } else {
        if (emboss_reserved_local_field_options.multiline()) {
          emboss_reserved_local_stream->Write(
              emboss_reserved_local_field_options.current_indent());
        }
        emboss_reserved_local_stream->Write("# v_is_first: UNREADABLE\n");
      }
    }

    (void)emboss_reserved_local_wrote_field;
    if (emboss_reserved_local_options.multiline()) {
      emboss_reserved_local_stream->Write(
          emboss_reserved_local_options.current_indent());
      emboss_reserved_local_stream->Write("}");
    } else {
      emboss_reserved_local_stream->Write(" }");
    }
  }



  static constexpr bool IsAggregate() { return true; }

 public:
  typename ::emboss::support::EnumView<
    /**/ ::emboss::test::EnumDefault,
    ::emboss::support::FixedSizeViewParameters<32, ::emboss::support::AllValuesAreOk>,
    typename ::emboss::support::BitBlock</**/::emboss::support::LittleEndianByteOrderer<typename Storage::template OffsetStorageType</**/0, 0>>, 32>>

 v() const;
  ::emboss::support::Maybe<bool> has_v() const;

 public:
  class EmbossReservedVirtualFirstView final {
   public:
    using ValueType = ::emboss::test::EnumDefault;

    constexpr EmbossReservedVirtualFirstView() {}
    EmbossReservedVirtualFirstView(const EmbossReservedVirtualFirstView &) = default;
    EmbossReservedVirtualFirstView(EmbossReservedVirtualFirstView &&) = default;
    EmbossReservedVirtualFirstView &operator=(const EmbossReservedVirtualFirstView &) =
        default;
    EmbossReservedVirtualFirstView &operator=(EmbossReservedVirtualFirstView &&) =
        default;
    ~EmbossReservedVirtualFirstView() = default;

    static constexpr ::emboss::test::EnumDefault Read();
    static constexpr ::emboss::test::EnumDefault UncheckedRead();
    static constexpr bool Ok() { return true; }
    template <class Stream>
    void WriteToTextStream(Stream *emboss_reserved_local_stream,
                           const ::emboss::TextOutputOptions
                               &emboss_reserved_local_options) const {
      ::emboss::support::WriteEnumViewToTextStream(
          this, emboss_reserved_local_stream, emboss_reserved_local_options);
    }

    static constexpr bool IsAggregate() { return false; }
  };

  static constexpr EmbossReservedVirtualFirstView first() {
    return EmbossReservedVirtualFirstView();
  }
  static constexpr ::emboss::support::Maybe<bool> has_first() {
    return ::emboss::support::Maybe<bool>(true);
  }

 public:
  class EmbossReservedVirtualVIsFirstView final {
   public:
    using ValueType = bool;

    explicit EmbossReservedVirtualVIsFirstView(
        const GenericUseKCamelEnumCaseView &emboss_reserved_local_view)
        : view_(emboss_reserved_local_view) {}
    EmbossReservedVirtualVIsFirstView() = delete;
    EmbossReservedVirtualVIsFirstView(const EmbossReservedVirtualVIsFirstView &) = default;
    EmbossReservedVirtualVIsFirstView(EmbossReservedVirtualVIsFirstView &&) = default;
    EmbossReservedVirtualVIsFirstView &operator=(const EmbossReservedVirtualVIsFirstView &) =
        default;
    EmbossReservedVirtualVIsFirstView &operator=(EmbossReservedVirtualVIsFirstView &&) =
        default;
    ~EmbossReservedVirtualVIsFirstView() = default;

    bool Read() const {
      EMBOSS_CHECK(view_.has_v_is_first().ValueOr(false));
      auto emboss_reserved_local_value = MaybeRead();
      EMBOSS_CHECK(emboss_reserved_local_value.Known());
      EMBOSS_CHECK(ValueIsOk(emboss_reserved_local_value.ValueOrDefault()));
      return emboss_reserved_local_value.ValueOrDefault();
    }
    bool UncheckedRead() const {
      return MaybeRead().ValueOrDefault();
    }
    bool Ok() const {
      auto emboss_reserved_local_value = MaybeRead();
      return emboss_reserved_local_value.Known() &&
             ValueIsOk(emboss_reserved_local_value.ValueOrDefault());
    }
    template <class Stream>
    void WriteToTextStream(Stream *emboss_reserved_local_stream,
                           const ::emboss::TextOutputOptions
                               &emboss_reserved_local_options) const {
      ::emboss::support::WriteBooleanViewToTextStream(
          this, emboss_reserved_local_stream, emboss_reserved_local_options);
    }

    static constexpr bool IsAggregate() { return false; }



   private:
    ::emboss::support::Maybe</**/ bool> MaybeRead() const {
      const auto emboss_reserved_local_subexpr_1 = view_.v();
      const auto emboss_reserved_local_subexpr_2 = (emboss_reserved_local_subexpr_1.Ok()    ? ::emboss::support::Maybe</**/::emboss::test::EnumDefault>(static_cast</**/::emboss::test::EnumDefault>(emboss_reserved_local_subexpr_1.UncheckedRead()))    : ::emboss::support::Maybe</**/::emboss::test::EnumDefault>());
      const auto emboss_reserved_local_subexpr_3 = ::emboss::support::Equal</**/::emboss::test::EnumDefault, bool, ::emboss::test::EnumDefault, ::emboss::test::EnumDefault>(emboss_reserved_local_subexpr_2, ::emboss::support::Maybe</**/::emboss::test::EnumDefault>(static_cast</**/::emboss::test::EnumDefault>(0)));

      return emboss_reserved_local_subexpr_3;
    }

    static constexpr bool ValueIsOk(
        bool emboss_reserved_local_value) {
      return (void)emboss_reserved_local_value,  // Silence -Wunused-parameter
             ::emboss::support::Maybe<bool>(true).ValueOr(false);
    }

    const GenericUseKCamelEnumCaseView view_;
  };
  EmbossReservedVirtualVIsFirstView v_is_first() const;
  ::emboss::support::Maybe<bool> has_v_is_first() const;

 public:
  class EmbossReservedDollarVirtualIntrinsicSizeInBytesView final {
   public:
    using ValueType = ::std::int32_t;

    constexpr EmbossReservedDollarVirtualIntrinsicSizeInBytesView() {}
    EmbossReservedDollarVirtualIntrinsicSizeInBytesView(const EmbossReservedDollarVirtualIntrinsicSizeInBytesView &) = default;
    EmbossReservedDollarVirtualIntrinsicSizeInBytesView(EmbossReservedDollarVirtualIntrinsicSizeInBytesView &&) = default;
    EmbossReservedDollarVirtualIntrinsicSizeInBytesView &operator=(const EmbossReservedDollarVirtualIntrinsicSizeInBytesView &) =
        default;
    EmbossReservedDollarVirtualIntrinsicSizeInBytesView &operator=(EmbossReservedDollarVirtualIntrinsicSizeInBytesView &&) =
        default;
    ~EmbossReservedDollarVirtualIntrinsicSizeInBytesView() = default;

    static constexpr ::std::int32_t Read();
    static constexpr ::std::int32_t UncheckedRead();
    static constexpr bool Ok() { return true; }
    template <class Stream>
    void WriteToTextStream(Stream *emboss_reserved_local_stream,
                           const ::emboss::TextOutputOptions
                               &emboss_reserved_local_options) const {
      ::emboss::support::WriteIntegerViewToTextStream(
          this, emboss_reserved_local_stream, emboss_reserved_local_options);
    }

    static constexpr bool IsAggregate() { return false; }
  };

  static constexpr EmbossReservedDollarVirtualIntrinsicSizeInBytesView IntrinsicSizeInBytes() {
    return EmbossReservedDollarVirtualIntrinsicSizeInBytesView();
  }
  static constexpr ::emboss::support::Maybe<bool> has_IntrinsicSizeInBytes() {
    return ::emboss::support::Maybe<bool>(true);
  }

 public:
  class EmbossReservedDollarVirtualMaxSizeInBytesView final {
   public:
    using ValueType = ::std::int32_t;

    constexpr EmbossReservedDollarVirtualMaxSizeInBytesView() {}
    EmbossReservedDollarVirtualMaxSizeInBytesView(const EmbossReservedDollarVirtualMaxSizeInBytesView &) = default;
    EmbossReservedDollarVirtualMaxSizeInBytesView(EmbossReservedDollarVirtualMaxSizeInBytesView &&) = default;
    EmbossReservedDollarVirtualMaxSizeInBytesView &operator=(const EmbossReservedDollarVirtualMaxSizeInBytesView &) =
        default;
    EmbossReservedDollarVirtualMaxSizeInBytesView &operator=(EmbossReservedDollarVirtualMaxSizeInBytesView &&) =
        default;
    ~EmbossReservedDollarVirtualMaxSizeInBytesView() = default;

    static constexpr ::std::int32_t Read();
    static constexpr ::std::int32_t UncheckedRead();
    static constexpr bool Ok() { return true; }
    template <class Stream>
    void WriteToTextStream(Stream *emboss_reserved_local_stream,
                           const ::emboss::TextOutputOptions
                               &emboss_reserved_local_options) const {
      ::emboss::support::WriteIntegerViewToTextStream(
          this, emboss_reserved_local_stream, emboss_reserved_local_options);
    }

    static constexpr bool IsAggregate() { return false; }
  };

  static constexpr EmbossReservedDollarVirtualMaxSizeInBytesView MaxSizeInBytes() {
    return EmbossReservedDollarVirtualMaxSizeInBytesView();
  }
  static constexpr ::emboss::support::Maybe<bool> has_MaxSizeInBytes() {
    return ::emboss::support::Maybe<bool>(true);
  }

 public:
  class EmbossReservedDollarVirtualMinSizeInBytesView final {
   public:
    using ValueType = ::std::int32_t;

    constexpr EmbossReservedDollarVirtualMinSizeInBytesView() {}
    EmbossReservedDollarVirtualMinSizeInBytesView(const EmbossReservedDollarVirtualMinSizeInBytesView &) = default;
    EmbossReservedDollarVirtualMinSizeInBytesView(EmbossReservedDollarVirtualMinSizeInBytesView &&) = default;
    EmbossReservedDollarVirtualMinSizeInBytesView &operator=(const EmbossReservedDollarVirtualMinSizeInBytesView &) =
        default;
    EmbossReservedDollarVirtualMinSizeInBytesView &operator=(EmbossReservedDollarVirtualMinSizeInBytesView &&) =
        default;
    ~EmbossReservedDollarVirtualMinSizeInBytesView() = default;

    static constexpr ::std::int32_t Read();
    static constexpr ::std::int32_t UncheckedRead();
    static constexpr bool Ok() { return true; }
    template <class Stream>
    void WriteToTextStream(Stream *emboss_reserved_local_stream,
                           const ::emboss::TextOutputOptions
                               &emboss_reserved_local_options) const {
      ::emboss::support::WriteIntegerViewToTextStream(
          this, emboss_reserved_local_stream, emboss_reserved_local_options);
    }

    static constexpr bool IsAggregate() { return false; }
  };

  static constexpr EmbossReservedDollarVirtualMinSizeInBytesView MinSizeInBytes() {
    return EmbossReservedDollarVirtualMinSizeInBytesView();
  }
  static constexpr ::emboss::support::Maybe<bool> has_MinSizeInBytes() {
    return ::emboss::support::Maybe<bool>(true);
  }



 private:
  Storage backing_;
  
  

  template <class OtherStorage>
  friend class GenericUseKCamelEnumCaseView;
};
using UseKCamelEnumCaseView =
    GenericUseKCamelEnumCaseView</**/ ::emboss::support::ReadOnlyContiguousBuffer>;
using UseKCamelEnumCaseWriter =
    GenericUseKCamelEnumCaseView</**/ ::emboss::support::ReadWriteContiguousBuffer>;

template <class View>
struct EmbossReservedInternalIsGenericUseKCamelEnumCaseView {
  static constexpr const bool value = false;
};

template <class Storage>
struct EmbossReservedInternalIsGenericUseKCamelEnumCaseView<
    GenericUseKCamelEnumCaseView<Storage>> {
  static constexpr const bool value = true;
};

template <typename T>
inline GenericUseKCamelEnumCaseView<
    /**/ ::emboss::support::ContiguousBuffer<
        typename ::std::remove_reference<
            decltype(*::std::declval<T>()->data())>::type,
        1, 0>>
MakeUseKCamelEnumCaseView( T &&emboss_reserved_local_arg) {
  return GenericUseKCamelEnumCaseView<
      /**/ ::emboss::support::ContiguousBuffer<
          typename ::std::remove_reference<decltype(
              *::std::declval<T>()->data())>::type,
          1, 0>>(
       ::std::forward<T>(emboss_reserved_local_arg));
}

template <typename T>
inline GenericUseKCamelEnumCaseView</**/ ::emboss::support::ContiguousBuffer<T, 1, 0>>
MakeUseKCamelEnumCaseView( T *emboss_reserved_local_data,
                 ::std::size_t emboss_reserved_local_size) {
  return GenericUseKCamelEnumCaseView</**/ ::emboss::support::ContiguousBuffer<T, 1, 0>>(
       emboss_reserved_local_data,
      emboss_reserved_local_size);
}

template <typename T, ::std::size_t kAlignment>
inline GenericUseKCamelEnumCaseView<
    /**/ ::emboss::support::ContiguousBuffer<T, kAlignment, 0>>
MakeAlignedUseKCamelEnumCaseView(
     T *emboss_reserved_local_data,
    ::std::size_t emboss_reserved_local_size) {
  return GenericUseKCamelEnumCaseView<
      /**/ ::emboss::support::ContiguousBuffer<T, kAlignment, 0>>(
       emboss_reserved_local_data,
      emboss_reserved_local_size);
}
enum class EnumShoutyAndKCamel : ::std::uint64_t {
  FIRST = static_cast</**/::std::int32_t>(0LL),
  kFirst = static_cast</**/::std::int32_t>(0LL),
  SECOND = static_cast</**/::std::int32_t>(1LL),
  kSecond = static_cast</**/::std::int32_t>(1LL),
  TWO_WORD = static_cast</**/::std::int32_t>(2LL),
  kTwoWord = static_cast</**/::std::int32_t>(2LL),
  THREE_WORD_ENUM = static_cast</**/::std::int32_t>(4LL),
  kThreeWordEnum = static_cast</**/::std::int32_t>(4LL),
  LONG_ENUM_VALUE_NAME = static_cast</**/::std::int32_t>(8LL),
  kLongEnumValueName = static_cast</**/::std::int32_t>(8LL),

};
template <class Enum>
class EnumTraits;

template <>
class EnumTraits<EnumShoutyAndKCamel> final {
 public:
  static bool TryToGetEnumFromName(const char *emboss_reserved_local_name,
                                   EnumShoutyAndKCamel *emboss_reserved_local_result) {
    if (emboss_reserved_local_name == nullptr) return false;
    if (!strcmp("FIRST", emboss_reserved_local_name)) {
      *emboss_reserved_local_result = EnumShoutyAndKCamel::FIRST;
      return true;
    }

    if (!strcmp("FIRST", emboss_reserved_local_name)) {
      *emboss_reserved_local_result = EnumShoutyAndKCamel::kFirst;
      return true;
    }

    if (!strcmp("SECOND", emboss_reserved_local_name)) {
      *emboss_reserved_local_result = EnumShoutyAndKCamel::SECOND;
      return true;
    }

    if (!strcmp("SECOND", emboss_reserved_local_name)) {
      *emboss_reserved_local_result = EnumShoutyAndKCamel::kSecond;
      return true;
    }

    if (!strcmp("TWO_WORD", emboss_reserved_local_name)) {
      *emboss_reserved_local_result = EnumShoutyAndKCamel::TWO_WORD;
      return true;
    }

    if (!strcmp("TWO_WORD", emboss_reserved_local_name)) {
      *emboss_reserved_local_result = EnumShoutyAndKCamel::kTwoWord;
      return true;
    }

    if (!strcmp("THREE_WORD_ENUM", emboss_reserved_local_name)) {
      *emboss_reserved_local_result = EnumShoutyAndKCamel::THREE_WORD_ENUM;
      return true;
    }

    if (!strcmp("THREE_WORD_ENUM", emboss_reserved_local_name)) {
      *emboss_reserved_local_result = EnumShoutyAndKCamel::kThreeWordEnum;
      return true;
    }

    if (!strcmp("LONG_ENUM_VALUE_NAME", emboss_reserved_local_name)) {
      *emboss_reserved_local_result = EnumShoutyAndKCamel::LONG_ENUM_VALUE_NAME;
      return true;
    }

    if (!strcmp("LONG_ENUM_VALUE_NAME", emboss_reserved_local_name)) {
      *emboss_reserved_local_result = EnumShoutyAndKCamel::kLongEnumValueName;
      return true;
    }

    return false;
  }

  static const char *TryToGetNameFromEnum(
      EnumShoutyAndKCamel emboss_reserved_local_value) {
    switch (emboss_reserved_local_value) {
      case EnumShoutyAndKCamel::FIRST: return "FIRST";

      case EnumShoutyAndKCamel::SECOND: return "SECOND";

      case EnumShoutyAndKCamel::TWO_WORD: return "TWO_WORD";

      case EnumShoutyAndKCamel::THREE_WORD_ENUM: return "THREE_WORD_ENUM";

      case EnumShoutyAndKCamel::LONG_ENUM_VALUE_NAME: return "LONG_ENUM_VALUE_NAME";

      default: return nullptr;
    }
  }

  static bool EnumIsKnown(EnumShoutyAndKCamel emboss_reserved_local_value) {
    switch (emboss_reserved_local_value) {
      case EnumShoutyAndKCamel::FIRST: return true;

      case EnumShoutyAndKCamel::SECOND: return true;

      case EnumShoutyAndKCamel::TWO_WORD: return true;

      case EnumShoutyAndKCamel::THREE_WORD_ENUM: return true;

      case EnumShoutyAndKCamel::LONG_ENUM_VALUE_NAME: return true;

      default:
        return false;
    }
  }

  static ::std::ostream &SendToOstream(::std::ostream &emboss_reserved_local_os,
                                       EnumShoutyAndKCamel emboss_reserved_local_value) {
    const char *emboss_reserved_local_name =
        TryToGetNameFromEnum(emboss_reserved_local_value);
    if (emboss_reserved_local_name == nullptr) {
      emboss_reserved_local_os
          << static_cast</**/ ::std::underlying_type<EnumShoutyAndKCamel>::type>(
                 emboss_reserved_local_value);
    } else {
      emboss_reserved_local_os << emboss_reserved_local_name;
    }
    return emboss_reserved_local_os;
  }
};

static inline bool TryToGetEnumFromName(
    const char *emboss_reserved_local_name,
    EnumShoutyAndKCamel *emboss_reserved_local_result) {
  return EnumTraits<EnumShoutyAndKCamel>::TryToGetEnumFromName(
      emboss_reserved_local_name, emboss_reserved_local_result);
}

static inline const char *TryToGetNameFromEnum(
    EnumShoutyAndKCamel emboss_reserved_local_value) {
  return EnumTraits<EnumShoutyAndKCamel>::TryToGetNameFromEnum(
      emboss_reserved_local_value);
}

static inline bool EnumIsKnown(EnumShoutyAndKCamel emboss_reserved_local_value) {
  return EnumTraits<EnumShoutyAndKCamel>::EnumIsKnown(emboss_reserved_local_value);
}

static inline ::std::ostream &operator<<(
    ::std::ostream &emboss_reserved_local_os,
    EnumShoutyAndKCamel emboss_reserved_local_value) {
  return EnumTraits<EnumShoutyAndKCamel>::SendToOstream(emboss_reserved_local_os,
                                             emboss_reserved_local_value);
}
enum class EnumMixed : ::std::uint64_t {
  FIRST = static_cast</**/::std::int32_t>(0LL),
  kFirst = static_cast</**/::std::int32_t>(0LL),
  SECOND = static_cast</**/::std::int32_t>(1LL),
  kTwoWord = static_cast</**/::std::int32_t>(2LL),
  kThreeWordEnum = static_cast</**/::std::int32_t>(4LL),
  THREE_WORD_ENUM = static_cast</**/::std::int32_t>(4LL),
  kLongEnumValueName = static_cast</**/::std::int32_t>(8LL),

};
template <class Enum>
class EnumTraits;

template <>
class EnumTraits<EnumMixed> final {
 public:
  static bool TryToGetEnumFromName(const char *emboss_reserved_local_name,
                                   EnumMixed *emboss_reserved_local_result) {
    if (emboss_reserved_local_name == nullptr) return false;
    if (!strcmp("FIRST", emboss_reserved_local_name)) {
      *emboss_reserved_local_result = EnumMixed::FIRST;
      return true;
    }

    if (!strcmp("FIRST", emboss_reserved_local_name)) {
      *emboss_reserved_local_result = EnumMixed::kFirst;
      return true;
    }

    if (!strcmp("SECOND", emboss_reserved_local_name)) {
      *emboss_reserved_local_result = EnumMixed::SECOND;
      return true;
    }

    if (!strcmp("TWO_WORD", emboss_reserved_local_name)) {
      *emboss_reserved_local_result = EnumMixed::kTwoWord;
      return true;
    }

    if (!strcmp("THREE_WORD_ENUM", emboss_reserved_local_name)) {
      *emboss_reserved_local_result = EnumMixed::kThreeWordEnum;
      return true;
    }

    if (!strcmp("THREE_WORD_ENUM", emboss_reserved_local_name)) {
      *emboss_reserved_local_result = EnumMixed::THREE_WORD_ENUM;
      return true;
    }

    if (!strcmp("LONG_ENUM_VALUE_NAME", emboss_reserved_local_name)) {
      *emboss_reserved_local_result = EnumMixed::kLongEnumValueName;
      return true;
    }

    return false;
  }

  static const char *TryToGetNameFromEnum(
      EnumMixed emboss_reserved_local_value) {
    switch (emboss_reserved_local_value) {
      case EnumMixed::FIRST: return "FIRST";

      case EnumMixed::SECOND: return "SECOND";

      case EnumMixed::kTwoWord: return "TWO_WORD";

      case EnumMixed::kThreeWordEnum: return "THREE_WORD_ENUM";

      case EnumMixed::kLongEnumValueName: return "LONG_ENUM_VALUE_NAME";

      default: return nullptr;
    }
  }

  static bool EnumIsKnown(EnumMixed emboss_reserved_local_value) {
    switch (emboss_reserved_local_value) {
      case EnumMixed::FIRST: return true;

      case EnumMixed::SECOND: return true;

      case EnumMixed::kTwoWord: return true;

      case EnumMixed::kThreeWordEnum: return true;

      case EnumMixed::kLongEnumValueName: return true;

      default:
        return false;
    }
  }

  static ::std::ostream &SendToOstream(::std::ostream &emboss_reserved_local_os,
                                       EnumMixed emboss_reserved_local_value) {
    const char *emboss_reserved_local_name =
        TryToGetNameFromEnum(emboss_reserved_local_value);
    if (emboss_reserved_local_name == nullptr) {
      emboss_reserved_local_os
          << static_cast</**/ ::std::underlying_type<EnumMixed>::type>(
                 emboss_reserved_local_value);
    } else {
      emboss_reserved_local_os << emboss_reserved_local_name;
    }
    return emboss_reserved_local_os;
  }
};

static inline bool TryToGetEnumFromName(
    const char *emboss_reserved_local_name,
    EnumMixed *emboss_reserved_local_result) {
  return EnumTraits<EnumMixed>::TryToGetEnumFromName(
      emboss_reserved_local_name, emboss_reserved_local_result);
}

static inline const char *TryToGetNameFromEnum(
    EnumMixed emboss_reserved_local_value) {
  return EnumTraits<EnumMixed>::TryToGetNameFromEnum(
      emboss_reserved_local_value);
}

static inline bool EnumIsKnown(EnumMixed emboss_reserved_local_value) {
  return EnumTraits<EnumMixed>::EnumIsKnown(emboss_reserved_local_value);
}

static inline ::std::ostream &operator<<(
    ::std::ostream &emboss_reserved_local_os,
    EnumMixed emboss_reserved_local_value) {
  return EnumTraits<EnumMixed>::SendToOstream(emboss_reserved_local_os,
                                             emboss_reserved_local_value);
}

namespace UseKCamelEnumCase {

}  // namespace UseKCamelEnumCase


template <class Storage>
inline typename ::emboss::support::EnumView<
    /**/ ::emboss::test::EnumDefault,
    ::emboss::support::FixedSizeViewParameters<32, ::emboss::support::AllValuesAreOk>,
    typename ::emboss::support::BitBlock</**/::emboss::support::LittleEndianByteOrderer<typename Storage::template OffsetStorageType</**/0, 0>>, 32>>

 GenericUseKCamelEnumCaseView<Storage>::v()
    const {

  if ( has_v().ValueOr(false)) {

    auto emboss_reserved_local_size = ::emboss::support::Maybe</**/::std::int32_t>(static_cast</**/::std::int32_t>(4LL));
    auto emboss_reserved_local_offset = ::emboss::support::Maybe</**/::std::int32_t>(static_cast</**/::std::int32_t>(0LL));
    if (emboss_reserved_local_size.Known() &&
        emboss_reserved_local_size.ValueOr(0) >= 0 &&
        emboss_reserved_local_offset.Known() &&
        emboss_reserved_local_offset.ValueOr(0) >= 0) {
        return ::emboss::support::EnumView<
    /**/ ::emboss::test::EnumDefault,
    ::emboss::support::FixedSizeViewParameters<32, ::emboss::support::AllValuesAreOk>,
    typename ::emboss::support::BitBlock</**/::emboss::support::LittleEndianByteOrderer<typename Storage::template OffsetStorageType</**/0, 0>>, 32>>

(
                 backing_
                        .template GetOffsetStorage<0,
                                                   0>(
                                emboss_reserved_local_offset.ValueOrDefault(),
                                emboss_reserved_local_size.ValueOrDefault()));
    }
  }
  return ::emboss::support::EnumView<
    /**/ ::emboss::test::EnumDefault,
    ::emboss::support::FixedSizeViewParameters<32, ::emboss::support::AllValuesAreOk>,
    typename ::emboss::support::BitBlock</**/::emboss::support::LittleEndianByteOrderer<typename Storage::template OffsetStorageType</**/0, 0>>, 32>>

();
}

template <class Storage>
inline ::emboss::support::Maybe<bool>
GenericUseKCamelEnumCaseView<Storage>::has_v() const {
  return ::emboss::support::Maybe</**/bool>(true);
}


namespace UseKCamelEnumCase {
inline constexpr ::emboss::test::EnumDefault first() {
  return ::emboss::support::Maybe</**/::emboss::test::EnumDefault>(static_cast</**/::emboss::test::EnumDefault>(0)).ValueOrDefault();
}
}  // namespace UseKCamelEnumCase

template <class Storage>
inline constexpr ::emboss::test::EnumDefault
GenericUseKCamelEnumCaseView<Storage>::EmbossReservedVirtualFirstView::Read() {
  return UseKCamelEnumCase::first();
}

template <class Storage>
inline constexpr ::emboss::test::EnumDefault
GenericUseKCamelEnumCaseView<
    Storage>::EmbossReservedVirtualFirstView::UncheckedRead() {
  return UseKCamelEnumCase::first();
}

template <class Storage>
inline typename GenericUseKCamelEnumCaseView<Storage>::EmbossReservedVirtualVIsFirstView
GenericUseKCamelEnumCaseView<Storage>::v_is_first() const {
  return
      typename GenericUseKCamelEnumCaseView<Storage>::EmbossReservedVirtualVIsFirstView(
          *this);
}

template <class Storage>
inline ::emboss::support::Maybe<bool>
GenericUseKCamelEnumCaseView<Storage>::has_v_is_first() const {
  return ::emboss::support::Maybe</**/bool>(true);
}


namespace UseKCamelEnumCase {
inline constexpr ::std::int32_t IntrinsicSizeInBytes() {
  return ::emboss::support::Maybe</**/::std::int32_t>(static_cast</**/::std::int32_t>(4LL)).ValueOrDefault();
}
}  // namespace UseKCamelEnumCase

template <class Storage>
inline constexpr ::std::int32_t
GenericUseKCamelEnumCaseView<Storage>::EmbossReservedDollarVirtualIntrinsicSizeInBytesView::Read() {
  return UseKCamelEnumCase::IntrinsicSizeInBytes();
}

template <class Storage>
inline constexpr ::std::int32_t
GenericUseKCamelEnumCaseView<
    Storage>::EmbossReservedDollarVirtualIntrinsicSizeInBytesView::UncheckedRead() {
  return UseKCamelEnumCase::IntrinsicSizeInBytes();
}

namespace UseKCamelEnumCase {
inline constexpr ::std::int32_t MaxSizeInBytes() {
  return ::emboss::support::Maybe</**/::std::int32_t>(static_cast</**/::std::int32_t>(4LL)).ValueOrDefault();
}
}  // namespace UseKCamelEnumCase

template <class Storage>
inline constexpr ::std::int32_t
GenericUseKCamelEnumCaseView<Storage>::EmbossReservedDollarVirtualMaxSizeInBytesView::Read() {
  return UseKCamelEnumCase::MaxSizeInBytes();
}

template <class Storage>
inline constexpr ::std::int32_t
GenericUseKCamelEnumCaseView<
    Storage>::EmbossReservedDollarVirtualMaxSizeInBytesView::UncheckedRead() {
  return UseKCamelEnumCase::MaxSizeInBytes();
}

namespace UseKCamelEnumCase {
inline constexpr ::std::int32_t MinSizeInBytes() {
  return ::emboss::support::Maybe</**/::std::int32_t>(static_cast</**/::std::int32_t>(4LL)).ValueOrDefault();
}
}  // namespace UseKCamelEnumCase

template <class Storage>
inline constexpr ::std::int32_t
GenericUseKCamelEnumCaseView<Storage>::EmbossReservedDollarVirtualMinSizeInBytesView::Read() {
  return UseKCamelEnumCase::MinSizeInBytes();
}

template <class Storage>
inline constexpr ::std::int32_t
GenericUseKCamelEnumCaseView<
    Storage>::EmbossReservedDollarVirtualMinSizeInBytesView::UncheckedRead() {
  return UseKCamelEnumCase::MinSizeInBytes();
}



}  // namespace test



}  // namespace emboss



/* NOLINTEND */

#endif  // TESTDATA_ENUM_CASE_EMB_H_

